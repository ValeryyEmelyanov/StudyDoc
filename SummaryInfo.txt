Закрытые лекции: 1.1-1.2; 7.1;
_______________________________________________________________________________________________________________________
Вопросы: Использование глобальной сборки ПАКА - через конфигурации? К разным базам
         Не совсем понятно с положение http путей. Должны быть в одном классе или могут быть разбросаны

_______________________________________________________________________________________________________________________
    Spring в действии:
        Spring - контейнер, предлагающий создание bean компонентов приложения и управление ими.
        Объединение bean компонентов внутри контекста (контейнера) Spring образует приложение.
        Объединение происходит по шаблону внедрения зависимостей Dependency Injection
        Spring Boot - расширение Framework, предлагающее некоторые расширения, наиболее известное - автоконфигурация
        обоснованные предположения о том, какие компоненты следует связать вместе.
        В основе работы Spring лежит Reflection API из Java Core
_______________________________________________________________________________________________________________________
    @Bean - объект, находящийся под управлением Spring. Завершенный прогматичный элеент с определенной бизнесс функцией
    По умолчанию Bean - Singleton
    Inversion of Control (IOC) - Spring сам производит вызов нужного ему объекта
    Dependency Injection - Реализация класса зависит от того, кто его инициализирует
    Dependency Inversion - Модули верхних уровней не должны зависить от модуей нижних уровней - оба должны зависеть
    от абстракций.
_______________________________________________________________________________________________________________________
    Basic class:
       @SpringBootApplication - составная конфигурация, состоит из:
            @SpringBootConfiguration - Определяет класс как конфигурацию
            @EnableAutoConfiguration - Включает автоконфигурацию
            @ComponentScan - Включает сканирование всех компонентов (@Component, @Controller, @Service)

        Basic test class:
       @SpringBootTest - Настройка Junit, составная конфигурация:
                 @ExtendWith(SpringExtension.class) - добавляет Junit 5
_______________________________________________________________________________________________________________________
    Spring Boot DevTools -набор дополнительных инструментов разработчика
        -Перезапускает приложение при изменении кода
        -Обновляет окно браузера
        -Отключает кеширование шаблонов
        -Встроенная консоль H2
_______________________________________________________________________________________________________________________
    Application properties - Описываются настройки БД и тд, которые касаются нашего приложения.
    Можно закладывать различные конфигурации
_______________________________________________________________________________________________________________________
    Spring MVC - контроллер - обрабатывает запросы и возвращает информацию
        Entity - модель базы
        @Controller- всего-лишь идентифицирует компонент как доступный для сканиррования
        Dto - форма для ввода или вывода
        @Component
        @Service
        @Repository
_______________________________________________________________________________________________________________________
       Сервер генерирует форму для заполнения -> Событие(кнопка)-> Получение формы (заполнение)-> Событие (кнопка) ->
   -> Получение формы (Если бы не Teamleaf, нужен @RequestParam)
        @GetMapping - добавление - возвращаем форму для заполнения
        @PostMapping - обновление - перенаправление 
_______________________________________________________________________________________________________________________
Jackson формирует и читает jason строчку - JS object Notation
   Формат данных для обмена в сети, формат данных: ключ - значение

   @JsonProperty - указывает название свойства в jason строчке
   @JsonIgnore - исклоючает поле из сериализации/десириализации
   @JsonInclude - (валидация?) можно указывать над свойство и над классом, свойство должно соблюдаться,
   для включения в json
        NON_DEFAULT - включает только недефолтные поля
                * Возможна проблема с нулями, фолсами и т.д.
        NON_NULL - включает только не пустые строчки
                * Только про ссылочные типы
   @JsonNaming(PropertyNamingStrategies) - задает стиль задачи имен для переменных (KamelCase, Snake_case и др)
        При наличии взаимных ссылок:
   @JsonManagedReference – это прямая часть ссылки, которая сериализуется обычным образом
   @JsonBackReference – это обратная часть ссылки - она будет опущена при сериализации
   @JsonIdentityInfo - Подставляет уникальный идентификатор вместо ссылки
   _
   @JsonSerialize (Ссылка на класс), в классе правила, сериализации/десериализации
   @JsonDeserialize
   @JsonIgnoreType - параметры передаются как единый объект, без названия параметра

_______________________________________________________________________________________________________________________
    @Autowired - Применяется к конструкторам или методам. Обозначает поле, в которое нужно внедрить Bean
    @Column - задает имя в таблице

    @Primary - используется при конфликте бинов, для выделения выбора
    @Qualifier - Указываем имя бина в (""), там, где нужно именно оне обозначаем имя через аннотацию

    @RequestMapping() - по умолчанию прооизводит сопоставление со всеми HTTP методами
    @RequestBody - обеспечаивает доступ к телу HTTP запроса, содержимое преобразуется в явный тип агрумента метода
    @ResponseBody - в теле сообщения возвращается та строка, которую возвращает метод если его нет, то возвращается
название html файла, на который мы переходим.

_______________________________________________________________________________________________________________________
    Работа методов - Get запрос->Controller->Service->Repository->Entity->Post запрос - Создание в обратном порядке

_______________________________________________________________________________________________________________________
Перенаправление на страницу - Нажатие кнопки пользователем (событие) ->
                              Сервер получает запрос ->
                              Обработка контроллером ->
                              Контроллер возвращает имя шаблона ->
                              Thymeleaf рендерит HTML страницу
_______________________________________________________________________________________________________________________
    Запросы:
        POST - если приходит пост запрос - происходит добавление (если PK уже существует - будет оишбка)
        PUT - что в теле сообщения пришло - то и обновляется в таблице
        PATCH - обновляет то, что приходит в теле сообщения
        DELETE - не реализуем, вместо него два предыдущих.
_______________________________________________________________________________________________________________________
    Управление БД

    ORM создает БД с помощью миграций (процесс), для более тонкой настройки используются дополнительные библиотеки:
    liquidbase/flyway  - управление структурой БД. Changlog выплняются при старте приложений. Требуется обновление в
    applicationproperty
    Jpa Buddy Plugin - управляет созданием



    Changelog - файлики с командами для управления. Результирующий файл также changelog
    Changelog - состаит из changset (к примеру: создание таблицы, обновление таблицы, создание связи между таблицами)
    м.б. представлени как xml, sql команды

    Управление состояние БД - управление миграциями
_______________________________________________________________________________________________________________________
    Многопоточка используется также как и в Java Core                                                                   @Configuration
    Если нужно создать пул потоков - создается бин, по имени которого потом вызываем                                    public class ProjectConfiguration {
    1 метод - 1 пул, возвразаем экзекьютор
    Когда хотим выполнить какой-либо метод как асинхронную задачу, над ним ставим @Async("название пула")               public Executor orderExecutor(){
    Прописываем метод в анатации которого обозначаем пул - расписываем пул - в сервисе вызываемметод                    ThreadPoolTaskExecutor executor =
                                                                                                                                        new ThreadPoolTaskExecutor();
    Запуск по расписанию:                                                                                                       executor.setCorePoolSize(1);
        @EnebleScheduling - аннотация над классом для запуска метода по расписанию                                              executor.setMaxPoolSize(5);
        @Scheduled - над самим методом + @Async - будет пул спринга                                                             executor.setQueueCapacity(20);
                                                                                                                                executor.setKeepAliveSeconds(60);
        Для работы с временем метод должен имплементить Delayed                                                                 executor.setThreadNamePrefix("XXX-EXECUTOR-");
        переопределять getDelay и compareTo                                                                                     executor.initialize();
                                                                                                                                return executor;
                                                                                                                            }
                                                                                                                        }
_______________________________________________________________________________________________________________________
    Ошибки/Исключения
    Можем создавать Exception и создавать их иерархию
    Ошибку проверяем через if если не проходим - выкидываем Exception, если проходим - отдаем результат
    За счет дополненния кастомной ошибки своего исключения, можем добавлять поле статус, и выделять кастомную ошибку
    Для необычных ошибок, но постоянных (вместо 500-ой должны возвращать 200) можно использовать Controller Advice - Это
    нестандартная постоянная ситуация.
    Либо Controller Advice через @ControllerAdvice
    Для обработки исключения @ExceptionHandler (вид исключения для обработки) - пишем паблик метод с своим названием
    Он будет перехватывать ошибки и экземпляр придет в этот метод.
    Получаем метод и статус.
                             @ResponseStatus задаем статус, тогда обработка будет в Controller Advice
                             @ResponseBody - в теле уйдет тело в метод обработки

                                        либо ResponseStatusExceptions - Service - throw new танзвание (статус, сообщение)
                                        в Controller в блоке try-cath перехватываем
    @ExceptionHandler
    @ResponseStatus

    На каждый статус возвращается своя страничка или прописывается единообразная

_______________________________________________________________________________________________________________________

    Java Mail Sender
    Настройки находятся в проперти файле для отправки писем
    smtp(465)/smtps(8043)

    Создается письмо в SimpleMeilMessege (setFrom, setTo, setSubject, setText)
    Вложения реализуются через MimeMessage (файлики)
    Если прописано взаимодействие с сторонним сервисом, то через http
_______________________________________________________________________________________________________________________
    Логирование
    Возможности включены в Spring Boot - @Slf4j дает доступ к log. Default - Log4j
                    info - хотим зафиксировать какую-либо информацию (остается в промышленной среде и попадает в логи)
                    debug - информация для отладки (только на стадии разработки)
                    error - логирование Exception

            МОжешь просто передать строчку, а можем добавить объект Frolable или на какой либо другой объект
