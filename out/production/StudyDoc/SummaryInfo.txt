Закрытые лекции: 1.1-1.2;2.1,2.2,2.3,3.1,4.1,4.2,  7.1;

Spring быстро


_______________________________________________________________________________________________________________________
ООП

    ООП - методология программирования, основаная на представлении программы как совокупности объектов, каждый из
 которых является экземпляром определенного класса, а классы образуют иерархию наследования. Согласно парадигме
 программа состоит из объектов, которые обмениваются сообщениями.
    Инкапсуляция - сокрытие реализации.
    Наследование - создание новой сущности на базе уже существующей.
    Полиморфизм - возможность иметь разные формы для одной и той же сущности.
    Абстракция - набор общих характеристик.
    Посылка сообщений - форма связи, взаимодействия между сущностями.
    Переиспользование- все что перечислено выше работает на повторное использование кода.

Инкапсуляция - механизм системы, в котором происходит объединение данные и методды в единый объект и скрыть его работу
Цель - уйти от зависимости от внещнего интерфейса.

Наследование – это свойство системы, позволяющее описать новый класс на основе уже существующего с
частично или полностью заимствующейся функциональностью.

Класс, от которого производится наследование, называется предком, базовым или родительским. Новый класс – потомком,
наследником или производным классом.

Полиморфизм – это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и
внутренней структуре объекта.

Абстрагирование – это способ выделить набор общих характеристик объекта, исключая из рассмотрения частные и незначимые.
Соответственно, абстракция – это набор всех таких характеристик.

Объекты взаимодействуют, посылая и получая сообщения. Сообщение — это запрос на выполнение действия, дополненный
набором аргументов, которые могут понадобиться при выполнении действия. В ООП посылка сообщения (вызов метода) — это
единственный путь передать управление объекту. Если объект должен «отвечать» на это сообщение, то у него должна иметься
соответствующий данному сообщению метод. Так же объекты, используя свои методы, могут и сами посылать сообщения
другим объектам. Обмен сообщениями реализуется с помощью динамических вызовов, что приводит к чрезвычайно
позднему связыванию (extreme late binding).

Класс – это способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также правила
для взаимодействия с данной сущностью (контракт).

С точки зрения программирования класс можно рассматривать как набор данных (полей, атрибутов, членов класса) и функций
для работы с ними (методов).

С точки зрения структуры программы, класс является сложным типом данных.

Объект (экземпляр) – это отдельный представитель класса, имеющий конкретное состояние и поведение, полностью
определяемое классом. Каждый объект имеет конкретные значения атрибутов и методы, работающие с этими значениями
на основе правил, заданных в классе.

Интерфейс – это набор методов класса, доступных для использования. Интерфейсом класса будет являться набор всех его
публичных методов в совокупности с набором публичных атрибутов. По сути, интерфейс специфицирует класс, чётко определяя
 все возможные действия над ним.
_______________________________________________________________________________________________________________________
 Ключевое слово Optional в Java
    Optional в Java — это специальный класс, введённый в версии Java 8, который служит контейнером для значений,
    которые могут быть либо null, либо содержать какое-то значение. Он помогает избежать распространенной ошибки,
    когда возникает NullPointerException, что улучшает читаемость и безопасность кода.
Основная цель Optional — сделать код более надежным и предсказуемым, минимизировав ситуации, когда разработчики
сталкиваются с null-значениями.
    isPresent() — проверяет, содержит ли Optional значение.
    get() — возвращает значение, если оно присутствует.
    orElse(T other) — возвращает значение, если оно есть, или возвращает переданное значение по умолчанию.
    orElseGet(Supplier<? extends T> supplier) — возвращает значение или выполняет функцию для
получения значения по умолчанию.
    orElseThrow(Supplier<? extends X> exceptionSupplier) — возвращает значение или выбрасывает исключение.
    ifPresent(Consumer<? super T> action) — выполняет действие, если значение присутствует.
    map(Function<? super T, ? extends U> mapper) — преобразует значение, если оно присутствует, и возвращает
новый Optional.
    flatMap(Function<? super T, Optional<U>> mapper) — используется для работы с вложенными Optional.
    filter(Predicate<? super T> predicate) — проверяет, удовлетворяет ли значение заданному условию.

    Преимущества использования Optional
    Избегание NullPointerException: Явное указание на возможность отсутствия значения вынуждает разработчика
обрабатывать такие ситуации.
    Более чистый и читаемый код: Упрощает логику работы с значениями, которые могут быть null.
    Чёткое намерение: Использование Optional явно показывает, что метод или переменная может быть пустой.
    Антипаттерны использования Optional
    Не использовать Optional для полей в классах. Optional лучше использовать для возвращаемых значений методов.
Хранение Optional в качестве полей объектов не рекомендуется, так как это нарушает концепцию того, как поля должны храниться.

    Не использовать Optional.get() без предварительной проверки. Это эквивалентно вызову метода на null,
что противоречит самой идее Optional.

_______________________________________________________________________________________________________________________
    Spring core - фкндоментальная часть с базовым функционалом. Работает по принципу IoC - предоставляем инструкцию
как пользоваться написанным нами кодом, не позволяем приложению управлять собственным выполнением посредством
его же кода или пользоваться зависимостями. (Управление - создание экземпляра или вызов метода)
    Spring MVC - позволяет создавать приложения, обрабатывающие HTTP запросы
    Spring Data Access - основыне инструменты для соединения с БД SQL.в этом модуле используется управление транзакциями
и интеграция с фреймворками, реальзующими объектно-реляционную привязку ORM
    Spring Testing - инструменты тестирования

    Реализация серверного приложения:
    Spring контейнер - управляет экземплярами объектов и обеспечивает взаимосвязь всего приложения
    Spring Security - настройка конфигурации и аутентификации
    Spring MVC and WebFlux - реализует конечные точки REST для общения с клиентом
        REST (Representational State Transfer) в Spring — это архитектурный стиль для создания веб-сервисов, которые
        взаимодействуют через стандартные HTTP методы (GET, POST, PUT, DELETE). Rest - возвращает объект - JSON/XML
    Spring Boot - упрощает конфигурации и снижает сложность
    Spring Integration - упрощает передачу сообщений в топики Kafka\JMS
    Spring Data - обеспечивает подключение к БД

    Maven - система сборки, загрузка зависимостей, для работы приложения, выполнение тестов, проверка соответствия
    синтаксима заданным правилам, проверка на наличие уязвимости в системе безопасности, компиляция приложения,
    упаковка приложения в архив.

     <dependencies>
     <dependency>
     <groupId>org.Springframework</groupId>
     <artifactId>Spring-context</artifactId>
     <version>5.2.6.RELEASE</version>
     </dependency>
     </dependencies>                                - Добавление зависимости для контекста Spring



_______________________________________________________________________________________________________________________
    Spring в действии:
        Spring - контейнер, предлагающий создание bean компонентов приложения и управление ими.
        Объединение bean компонентов внутри контекста (контейнера) Spring образует приложение.
        Объединение происходит по шаблону внедрения зависимостей Dependency Injection
        Spring Boot - расширение Framework, предлагающее некоторые расширения, наиболее известное - автоконфигурация
        обоснованные предположения о том, какие компоненты следует связать вместе.
        В основе работы Spring лежит Reflection API из Java Core
_______________________________________________________________________________________________________________________

    Inversion of Control (IOC) - Spring сам производит вызов нужного ему объекта
    Dependency Injection - Реализация класса зависит от того, кто его инициализирует
    Dependency Inversion - Модули верхних уровней не должны зависить от модуей нижних уровней - оба должны зависеть
    от абстракций.
_______________________________________________________________________________________________________________________
    Basic class:
       @SpringBootApplication - составная конфигурация, состоит из:
            @SpringBootConfiguration - Определяет класс как конфигурацию
            @EnableAutoConfiguration - Включает автоконфигурацию
            @ComponentScan - Включает сканирование всех компонентов (@Component, @Controller, @Service)

        Basic test class:
       @SpringBootTest - Настройка Junit, составная конфигурация:
                 @ExtendWith(SpringExtension.class) - добавляет Junit 5
_______________________________________________________________________________________________________________________
    Spring Boot DevTools -набор дополнительных инструментов разработчика
        -Перезапускает приложение при изменении кода
        -Обновляет окно браузера
        -Отключает кеширование шаблонов
        -Встроенная консоль H2
_______________________________________________________________________________________________________________________
    Application properties - Описываются настройки БД и тд, которые касаются нашего приложения.
    Можно закладывать различные конфигурации
_______________________________________________________________________________________________________________________
    Spring MVC - контроллер - обрабатывает запросы и возвращает информацию
    Сервисы - объекты, задачей которых является реалищация сценариевиспользования
    Репозитории - объекты, отвечающие за сохранность данных
        Entity - модель базы
        @Controller- всего-лишь идентифицирует компонент как доступный для сканиррования
        Dto - форма для ввода или вывода data transfer object
        proxies - задействования системы, расположенной вне проекта
        @Component
        @Service
        @Repository
_______________________________________________________________________________________________________________________
       Сервер генерирует форму для заполнения -> Событие(кнопка)-> Получение формы (заполнение)-> Событие (кнопка) ->
   -> Получение формы (Если бы не Teamleaf, нужен @RequestParam)
        @GetMapping - добавление - возвращаем форму для заполнения
        @PostMapping - обновление - перенаправление 
_______________________________________________________________________________________________________________________
Jackson формирует и читает jason строчку - JS object Notation
   Формат данных для обмена в сети, формат данных: ключ - значение

   @JsonProperty - указывает название свойства в jason строчке
   @JsonIgnore - исклоючает поле из сериализации/десириализации
   @JsonInclude - (валидация?) можно указывать над свойство и над классом, свойство должно соблюдаться,
   для включения в json
        NON_DEFAULT - включает только недефолтные поля
                * Возможна проблема с нулями, фолсами и т.д.
        NON_NULL - включает только не пустые строчки
                * Только про ссылочные типы
   @JsonNaming(PropertyNamingStrategies) - задает стиль задачи имен для переменных (KamelCase, Snake_case и др)
        При наличии взаимных ссылок:
   @JsonManagedReference – это прямая часть ссылки, которая сериализуется обычным образом
   @JsonBackReference – это обратная часть ссылки - она будет опущена при сериализации
   @JsonIdentityInfo - Подставляет уникальный идентификатор вместо ссылки
   _
   @JsonSerialize (Ссылка на класс), в классе правила, сериализации/десериализации
   @JsonDeserialize
   @JsonIgnoreType - параметры передаются как единый объект, без названия параметра

_______________________________________________________________________________________________________________________
    @Autowired - Применяется к конструкторам или методам. Обозначает поле, в которое нужно внедрить Bean
    @Column - задает имя в таблице

    @Primary - используется при конфликте бинов, для выделения выбора
    @Qualifier - Указываем имя бина в (""), там, где нужно именно оне обозначаем имя через аннотацию

    @RequestMapping() - по умолчанию прооизводит сопоставление со всеми HTTP методами
    @RequestBody - обеспечаивает доступ к телу HTTP запроса, содержимое преобразуется в явный тип агрумента метода
    @ResponseBody - в теле сообщения возвращается та строка, которую возвращает метод если его нет, то возвращается
название html файла, на который мы переходим.

_______________________________________________________________________________________________________________________
    Работа методов - Get запрос->Controller->Service->Repository->Entity->Post запрос - Создание в обратном порядке

_______________________________________________________________________________________________________________________
Перенаправление на страницу - Нажатие кнопки пользователем (событие) ->
                              Сервер получает запрос ->
                              Обработка контроллером ->
                              Контроллер возвращает имя шаблона ->
                              Thymeleaf рендерит HTML страницу
_______________________________________________________________________________________________________________________
    @Configuration - характерный признак класса конфигурации, определяющий параметры проекта. Позволяет, к примеру,
  добавить бины в контекст.

    @Bean - объект, находящийся под управлением Spring. Завершенный прогматичный элеент с определенной бизнесс функцией
    По умолчанию Bean - Singleton

    Для обращения к конкретному бину можно использовать поле name: @Bean(name = "miki");
    Также может использоваться аннотация @Primary - задавая значение по умолчанию.

    Инициализация контекста Spring
    public class main {
     public static void main(String[] args) {
        var context = new AnnotationConfigApplicationContext(
            ProjectConfig.class);
        }
    }
_______________________________________________________________________________________________________________________
    @Component - помечаются классы, экземпляры которых помещаются в Spring
    @ComponentScan - отмечается в классе конфигурации показывается где находятся классы @Component

    @Bean VS Стереотипные аннотации.
        Bean - оставляет контроль за экземпляром за пользователем. Можно создавать несколько экземпляров одного типа
        Каждый экземпляр - отдельный метод

        Стереотипные аннотации - контроль над экземпляром возможен только после создания его фреймворком, только один
        экземпляр класса в контексте. Не появляется шаблонный код -> более предпочтителен

    @Postcinstract - позволяет вносить изменения в стереотианый экземпляр после создания. Для этого нужна зависимость

    <dependency>
     <groupId>Javax.annotation</groupId>
     <artifactId>Javax.annotation-api</artifactId>
     <version>1.3.2</version>
    </dependency>

    @PreDestroy - метод выполняется перед закрытием и зачисткой контекста

    Бин в констекст можно добавлять программно через условия, для этого используется registerBean() - аргументы
        beanName; class; supplier (возвращает значение); varargs (аргумент переменной длинны)
_______________________________________________________________________________________________________________________
    Связывание бинов: - вызов метода, который создает бин (монтаж). Просто задать в бине ссылку на др бин
                      - настройка спринг для автомонтажа - вызов через обязательный параметр
                      - внедрение зависимостей
                      - @Autowired - внеддрение в поле класса - не можем помечать final
                                   - внедрение через параметр конструктора - ообъявляем final поле, затем даем конструктор
                                        с меткой Автовайред с определением поля
                                   - внедрение через сеттер - плохо, не надо

    @Qualifier - приоритет по умолчанию
    public Person(@Qualifier("parrot2") Parrot parrot)

    @Primary - выделение приоритетного бина
_______________________________________________________________________________________________________________________

  Абстракции в Spring

    Реализуется через интерфейсы, которые не имеют собственных экземпляров, поэтому добавление в контекст необязательно.


  Добавление объекта в Spring context производится для передачи контроля и расширения функционала

_______________________________________________________________________________________________________________________
    @Controller
    Клиент передает запрос в формате HTTP, HTTPS и тд. содержит в себе практически любой строчный формат, сервер
    обрабатывает запрос и отправляет ответ.
    Уровень представления - @ html страничка, @Rest json or xml текст - преобразует jackson.
    @RequestMapping - контроллер обратавыает запрос по ссылке (добавляется для каждого)
    @RequestBody - обязует передать информацию в теле сообщения - работает с json строчкой
    @RequestParam - обязует передать ионфомацию - если информация подается отдельно друг от друга
            name - задаем название параметра (если он отличный от клиента)
            defaultValue - задает значение по умолчанию
            @Request(Param/Body = false) - передача не обязательно, возвращает null только для ссылочных типов оболочек

    Паттерн front-controller (единая точка входа) - определяет в какой контроллер передать запрос Dispatcher Servlet

    GET("/{..}")
   public ... get..(@PathVariable) - в метод гет будет подставляться запрос, который передается в вызове

   Параметр может использоваться в строке поиска



    @ResponseEntity - можем возвращать сущность (тело), тогда в return соответственно прописывам
            new responseEntity <>(body,method, HttpStatus.Created)
_______________________________________________________________________________________________________________________
    REST - архитектурный стиль взаимодействия внутренних систем.

    Сервлет - объект Java, который напрямую взаимодействует с контейнером сервлетов. Контейнер получает http - передает
        запрос в сервлет, сервлет отправляет ответ клиенту, сделавшему запрос, а метод получает http ответ.

    В большинстве случаев данные передаются посредством HTTP-запроса одним из следующих способов:

     в виде параметра HTTP-запроса — это простой способ передачи значений от
    клиента к серверу в формате пары «ключ — значение». Параметры добавляются в URI как выражения запроса.
    Поэтому их также называют параметрами запроса. Этот метод следует использовать только для передачи небольших
    объемов данных;
        Применяется если: объем данных не очень велик и нужно передать необязательные данные, типиный пример-определение
            критериев поиска и фильтрации.

     в виде параметров заголовка HTTP-запроса. Как и параметры запроса, параметры заголовка передаются в заголовке
    HTTP-запроса. Главное различие между ними — параметры заголовка не попадают в URI. Этот способ также
    не подходит для больших объемов данных;

     переменная пути передает данные через сам путь запроса. Как и в случаях выше, переменные пути используются для
    небольших объемов данных. Но данный вариант передачи следует применять, если данные являются обязательными;

     в теле HTTP-запроса. Этот метод обычно применяется в случаях, когда нужно передать много данных (строки, но иногда
    и двоичные данные, такие как файлы). Мы рассмотрим его в главе 10, когда научимся создавать конечные точки REST.

    HTTP структура
        Пример запроса - Стартовая строка - POST(метод)/login (URL)/ HTTP 1.0(версия)
                         Заголовок (Headers) - Host, Content-Type, Content-Length
                         Тело сообщения (Body) - JSON

        Сервер - собирает, обрабатывает и отдает ресурсы.
        Адресс - собирает запросы URI
        Способ получения ресурсов - HTTP (Методы:
                                              GET - получить что-то от сервера
                                              POST - если приходит пост запрос - происходит добавление
                                              PUT - что в теле сообщения пришло - то и обновляется в таблице
                                              PATCH - обновляет то, что приходит в теле сообщения
                                              DELETE - не реализуем, вместо него два предыдущих.)
        Обратная связь - HTTP статус код: ( 200 - OK
                                            301 - Permanent Redirect
                                            301 - Temporary Redirect
                                            301 - Nit Modified
                                            401 - Unauthorized Error
                                            403 - Forbidden
                                            404 - Not Found
                                            405 - Method Not Allowed
                                            501 - Not Implemented
                                            502 - Bad Gateway
                                            503 - Service Unavailable
                                            504 - Gateway Timeout

        Передача данных в RestAPI - Query (GET) - параметры и параметры пути
                                    Тело запроса - JSON, XML

        Заголовки
        Куки
    Сериализация - процесс перевода данных в формат, понятный приложению

    REST - не помнит предыдущие запросы, по этой причине его называют Stateless - не имеющий состояния

    Проектирование - начинается с труктуры урлов. Один эндпоинт - одна сущность, для каждого эндпоинта - выходные
        параметры, который принимает сервер, способ реализациии, тело ответа при возможных status code


    Имя метода, версия, название родительской сущности во множественном числе, идентификатор сущности, потомок...

    Swagger - выделенный эндпоинт, в которой прописаны все методы

    Если REST - это множество окошек, каждое из которых эндпоинт, то soap - это конкретное окнов, в котором выполняются
        определенные правила.


    SOAP - протокол обмена структурированными сообщениями (xml). Может использоваться не только в HTTP

    GraphQL - язык запросов. Частичная самодокументация за счет строгости.

    WebSockets - протокол реалтайм соединения (чаты, графики)

    RPC - удаленный вызов процедуры
    GRPC - фреймворк, использующая удаленные вызовы. Популярная в микросервисах. Используется HTTP2 protobuf вместо json
        широкий инструментарий из коробки, удобный вызов процедур.

    tRPC -


_______________________________________________________________________________________________________________________

        REST - сервис

    Рест (передача состояния представления) обеспечивает доступ к функциональности через конечные точки.

        1. Обмен данными:
            Конечные точки - способ организовать коммуникацию между двумя приложениями. Представляют собой действие
                контроллера, связанного с http-методом и путем
            Возможные проблоемы: несогласованность времени выполнения метода контроллера и соединения http выозова
            Слишком большое количество обращений к одной точке может превести к черезмерной нагрузке и сбою
            Влиятие возможного сетевого сбоя

        @ResponseBody - действие контроллера не возвращает имя представления, а передает данные.
        @RestController - елси контроллер

        Ответ:
            В теле http ответа - способ представления JSON
            http ответ с статусом и заголовками.

             return ResponseEntity - возвращение определенного статуса
             .status(HttpStatus.ACCEPTED)
             .header("continent", "Europe")
             .header("capital", "Paris")
             .header("favorite_food", "cheese and wine")
             .body(c);
             }\

          @PostMapping("/payment") - перехват исключений
          public ResponseEntity<?> makePayment() {

          try {
          PaymentDetails paymentDetails =
          paymentService.processPayment();

          return ResponseEntity
          .status(HttpStatus.ACCEPTED)
          .body(paymentDetails);
          } catch (NotEnoughMoneyException e) {
          ErrorDetails errorDetails = new ErrorDetails();
          errorDetails.setMessage("Not enough money to make the payment.");
          return ResponseEntity
          .badRequest()
          .body(errorDetails);
          }
          }

          Но, для избежания дублирования кода лучше использовать аспекты

        @RestControllerAdvice
        public class ExceptionControllerAdvice {
         @ExceptionHandler(NotEnoughMoneyException.class)
         public ResponseEntity<ErrorDetails> exceptionNotEnoughMoneyHandler() {
         ErrorDetails errorDetails = new ErrorDetails();
         errorDetails.setMessage("Not enough money to make the payment.");
         return ResponseEntity
         .badRequest()
         .body(errorDetails);
         }
        }

        Тело запроса - используется при большом объеме данных - более 50-100 символов @RequestBody
        @RestController
        public class PaymentController {
         private static Logger logger =
         Logger.getLogger(PaymentController.class.getName());
         @PostMapping("/payment")
         public ResponseEntity<PaymentDetails> makePayment(
         @RequestBody PaymentDetails paymentDetails) {    - извлечение данных из тела http запроса
         logger.info("Received payment " +
         paymentDetails.getAmount());    - вывод в консоль сервера сумму платежа
         return ResponseEntity
         .status(HttpStatus.ACCEPTED)
         .body(paymentDetails);   - возвращение объекта с информацией
         }
        }
_______________________________________________________________________________________________________________________

    Вызов конечных точек REST
       1.  OpenFeign — инструмент из проекта Spring Cloud.
       2.  RestTemplate — инструмент, который применяется для вызова конечных точек REST, начиная со Spring 3.
       3.  WebClient — функция Spring, призванная стать заменой для RestTemplate.

    @RestController
    public class PaymentsController {
     private static Logger logger =                                         - вывод в консоль
     Logger.getLogger(PaymentsController.class.getName());
     @PostMapping("/payment")                                               - конечная точка http метода
     public ResponseEntity<Payment> createPayment(
     @RequestHeader String requestId,                                       - Точка получает заголовок и тело запроса
     @RequestBody Payment payment
     ) {
     logger.info("Received request with ID " + requestId +
     " ;Payment Amount: " + payment.getAmount());
     payment.setId(UUID.randomUUID().toString());                           - присвоение случайного ID
     return ResponseEntity                                                  - возвращение http ответа
     .status(HttpStatus.OK)
     .header("requestId", requestId)
     .body(payment);
     }
    }

    для реализации необходимо добавить
    <dependency>
     <groupId>org.springframework.cloud</groupId>
     <artifactId>spring-cloud-starter-openfeign</artifactId>
    </dependency>

    @FeignClient(name = "payments",                     - создание REST клиента
     url = "${name.service.url}")
    public interface PaymentsProxy {
     @PostMapping("/payment")                           - http метод конечной точки
     Payment createPayment(                             - определяем заголовки и тело запроса
     @RequestHeader String requestId,
     @RequestBody Payment payment);
    }

    @Configuration                                      - показываем где следует искать прокси контракты
    @EnableFeignClients(
     basePackages = "com.example.proxy")
    public class ProjectConfig {
    }

    @RestController                                     - класс с внедренным прокси контроллером
    public class PaymentsController {
     private final PaymentsProxy paymentsProxy;
     public PaymentsController(PaymentsProxy paymentsProxy) {
     this.paymentsProxy = paymentsProxy;
     }
     @PostMapping("/payment")
     public Payment createPayment(
     @RequestBody Payment payment
     ) {
     String requestId = UUID.randomUUID().toString();
     return paymentsProxy.createPayment(requestId, payment);
     }
    }

    RestTemplate не может - синхронный и ассинхрпонныйвызове конечных точек
                            сокращение кода и количества исключений
                            повторные вызовы и операции отката

    Для создания вызова - Описать HTTP заголовки, создать экземпляр HttpEntity, exchange меттодом получить ответ

    Пример прокси класса:

    @Component
    public class PaymentsProxy {
     private final RestTemplate rest;
     @Value("${name.service.url}")                                  - получаем урл платежей
     private String paymentsServiceUrl;

     public PaymentsProxy(RestTemplate rest) {                      - Внедряем из контекста рест типлате
     this.rest = rest;
     }

     public Payment createPayment(Payment payment) {
     String uri = paymentsServiceUrl + "/payment";
     HttpHeaders headers = new HttpHeaders();                       - создаем объект в котором определяются заголовки
     headers.add("requestId",
     UUID.randomUUID().toString());

     HttpEntity<Payment> httpEntity =
     new HttpEntity<>(payment, headers);                            - строим объект с данными запроса

     ResponseEntity<Payment> response =                             - отправляем запрос и извлекаем данные
     rest.exchange(uri,
     HttpMethod.POST,
     httpEntity,
     Payment.class);

     return response.getBody();                                     - возвращаем запрос
     }
    }

    Тогда класс контроллера
    @RestController
    public class PaymentsController {
     private final PaymentsProxy paymentsProxy;
     public PaymentsController(PaymentsProxy paymentsProxy) {
     this.paymentsProxy = paymentsProxy;
     }
     @PostMapping("/payment")
     public Payment createPayment(
     @RequestBody Payment payment
     ) {
     return paymentsProxy.createPayment(payment);
     }
    }
_______________________________________________________________________________________________________________________
    WebClient - основан на реактивном программировании

    <dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter-webflux</artifactId>
    </dependency>

    Добавление бина @Configuration
                    public class ProjectConfig {
                     @Bean
                     public WebClient webClient() {
                     return WebClient
                     .builder() Создаем бин WebClient и добавляем его в контекст Spring
                     .build();
                     }
                    }

    Прокси класс @Component
                 public class PaymentsProxy {
                  private final WebClient webClient;
                  @Value("${name.service.url}")
                  private String url;
                  public PaymentsProxy(WebClient webClient) {
                  this.webClient = webClient;
                  }
                  public Mono<Payment> createPayment(
                  String requestId,
                  Payment payment) {
                  return webClient.post()
                  .uri(url + "/payment")
                  .header("requestId", requestId)
                  .body(Mono.just(payment), Payment.class)
                  .retrieve()
                  .bodyToMono(Payment.class);
                  }
                 }
    Класс контроллера
    @RestController
    public class PaymentsController {
     private final PaymentsProxy paymentsProxy;
     public PaymentsController(PaymentsProxy paymentsProxy) {
     this.paymentsProxy = paymentsProxy;
     }
     @PostMapping("/payment")
     public Mono<Payment> createPayment(
     @RequestBody Payment payment
     ) {
     String requestId = UUID.randomUUID().toString();
     return paymentsProxy.createPayment(requestId, payment);
     }
    }
_______________________________________________________________________________________________________________________
    Жизненный цикл Bean - способ создания управления жизненным циклом называют областями видимости (scope)
            Часто встречающиеся - одиночка и прототип, также существуют запрос, сессия и приложение

    Одиночная область видимости - получают по умолчанию. Бины создаются при загрузке контекста, каждому присваивается
        имя - ID. Область видимости одиночная. Т.к.  один бин - одно обращение. Ничего общего с синглтоном, обозначает
        уникальность имени, а не нналичия. В такой вариации бины должны быть неизменяемые.
    При добавлении бина в репозиторий, мы можем обращаться к нему из сервиса с аннотацией @Autowired

    @Lazy - бин будет создан только в момент обращения - зло, применяется крайне редко и специфично

    Для создания изменяемых бинов необходимо делать их согласованными.
    @Scope(BeanDefinition.SCOPE_PROTOTYPE) - создание прототипного бина. В этом случае Spring сам создает объект, а не
        управляет им. Экземпляр создается при каждом обращении. Прототипные бины решают проблему конкурентности.
    @Autowired - получаем экземпляр из контекста и связываем. Внедрение в одиночные бины не имеет смысла


    область видимости в рамках запроса — Spring создает отдельный экземпляр класса бина для каждого HTTP-запроса.
        От каждого запроса от каждого клиента
        -Создается множество экземпляров бина
        -Экземпляры быстро чистятся сборщиком мусора
        -Не должна выполняться сложная логика

        Доступен только одному запросу
        -не годится для многопоточки.
        -в атрибутах можно сохранить данные, используемые в запросе
        -нельзя использовать для методов синхронизации

    область видимости в рамках сессии — Spring создает экземпляр и хранит его в памяти сервера в течение всей
        HTTP-сессии. @SessionScope
    Управляемый Spring объект, для которого фреймворк создает экземпляр, првязанный к http сессии

    Позволяют реализовать: Аутентификацию - данные пользователя сохраняются все время, пока пользователь перемещается
        по страницам приложения и отправляет запросы.
                           Карзина интернет магазина - пользователь посещает разные страницы приложения в поиске
        товаров, корзина все запоминает

    Экземпляры бинов сохраняются всю сессию -> слишком большое количество таких данных могут перегрузить систему
    Один экземпляр может быть доступен нескольким пользователям -> проблемы одновременного выполнения конкурентных запросов

    <body>  - добавление логаута
     <h1>Welcome, <span th:text="${username}"></span></h1>
     <a href="/main?Logout">Log out</a>
    </body>

    область видимости в рамках приложения — экземпляр является уникальным в контексте приложения и доступен все время
        работы приложения.  @ApplicationScope
    Лчше неиспользовать в реальных приложениях. Похож на одиночный бин, но недоступен для создания экземпляров
        Пример использования - счетчик аутентифицированных пользователей



    Логика аутентификации:

    @Controller
    public class LoginController {
     @GetMapping("/")
     public String loginGet() {
     return "login.html";
     }
     @PostMapping("/")
     public String loginPost(
     @RequestParam String username,
     @RequestParam String password,
     Model model
     ) {
     boolean loggedIn = false;
     if (loggedIn) {
     model.addAttribute("message", "You are now logged in.");
     } else {
     model.addAttribute("message", "Login failed!");
     }
     return "login.html";
     }
    }

    Логика с созданием бина в рамках запроса

    @Component
    @RequestScope
    public class LoginProcessor {
     private String username;
     private String password;
     public boolean login() {
     String username = this.getUsername();
     String password = this.getPassword();
     if ("natalie".equals(username) && "password".equals(password)) {
     return true;
     } else {
     return false;
     }
     }
     // геттеры и сеттеры
    }

    Использование аннотации @ComponentScan ??

_______________________________________________________________________________________________________________________
    АОП в Spring
        Аспект — это объект, перехватывающий вызов метода и выполняющий некую логику до, после или даже вместо
        выполнения перехваченного метода. Это позволяет отделить часть кода от бизнес-логики, благодаря чему приложение
        становится проще в обслуживании. Группирование, отделение части кода в аспект. необходимо определить:
                - Какой код должен выполнять Spring при вызове методом
                - Когда приложение должно выполнять эту логику
                - Какие методы должен перехватывать фреймворк
    Bean, в котором объявляется прерываемый аспектом метод - целевой объект. Взамен бину, Spring предлагает прокси
        объект. Такая технология называется вплетением. Прокси объект выполняет логику, после чего делигирует вызов
        исходному методу.

    </dependency>
    <dependency>
     <groupId>org.springframework</groupId>
     <artifactId>spring-aspects</artifactId>
     <version>5.2.8.RELEASE</version>
    </dependency>

    Для создания аспекта:
        1. Конфигурация @EnableAspectJAutoProxy - сообщаем в Spring, что используем аспекты
        2. Перед классом внедрить аннотацию @Aspect - методы, которые перехватывают и реализуют свою логику
            Класс добавляем в контекст Spring и указываем место сканирования @ComponentScan
        3. Определить метод реализации аспекта. С @Around - определить для аспекта какой метод и в какой момент
            перехватывать. @Around("execution(* services.*.*(..))") - язык выражений  AspectJ
        4. Реализация логики аспекта

    Аспекты позволяют: модифицировать значения параметров
                       изменять возвращаемые значения
                       выбрасывать исключения и обрабатывать его

    По умолчанию аннотации не перехватываются во время выполнения программы. RUNTIME. @Target определяет для каких
        элементов языка может использоваться конкретная аннотация
            @Retention(RetentionPolicy.RUNTIME) - активировать во время выполнения приложения
            @Target(ElementType.METHOD) - применять только для методов

            AspectJ: @annotation(ToLog) - выражение указывает на любой метод с аннотацией @ToLog

            @Around - можно сделать что-то до, после или вместо перехваченного метода
            @Before - перед выполнением метода
            @AfterReturning - после успешного завершения перехваченного метода
            @AfterThrowing  - перехваченный метод выдает исколючение
            @After - после выполнения, независимо от успешности

    Типичное применение аспектов: Существует метод, данные о выполнении которого нужно заносить  вжурнал и одновременно
        применять некие ограничения по безопасности:
                    SecurityAspect — применяет ограничения по безопасности.
                    LoggingAspect — заносит в журнал сообщения о начале и завершении работы
                    перехваченного метода
    Если последовательность выполнения аспектов в цепочке не важна - можем передать это на усмотрение Spring, если
        важна, то воспользуемся аннотацией @Order, чем меньше число, тем раньше аспект.

_______________________________________________________________________________________________________________________
    Реализация Spring Boot MVC

    <dependency>                                                        Thymeleaf и Web
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter-thymeleaf</artifactId>
    </dependency>
    <dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    шаблоны Thymeleaf — это просто статические HTML-файлы

    @Controller                                                         Контроллер с определением действия страницы.
    public class MainController {
     @RequestMapping("/home")
     public String home(Model page) {
     page.addAttribute("username", "Katy");
     page.addAttribute("color", "red");
     return "home.html";
     }
    }

    html страницу размещаем тут - resources/templates т.к. шаблон таймлиф
    <html> - первый тег с которого все начинается
    xmlns:th="http://www.thymeleaf.org" - эквивалент импорта в java

     <head>                                                            Выделение заголовка
     <meta charset="UTF-8">
     <title>Home Page</title>
     </head>

      <body>                                                          Тело страницы
      <h1>Welcome
      <span th:style="'color:' + ${color}"
      th:text="${username}"></span>!</h1>           -- тэг th для значений, передаваемых контроллером
      </body>

            Передача параметром запроса:
       @RequestMapping("/home")
       public String home(
       @RequestParam(required = false) String name,
       @RequestParam String color,                @RequestParam - определяем параметр для метода действия контроллера
       Model page) {                              Model используется для передачи данных из контроллера в представление
       page.addAttribute("username", "Katy");
       page.addAttribute("color", color);
       return "home.html";
       }

        Запрос для этой страницы http://localhost:8080/home?color=blue

        По умолчанию параметр запроса является обязательным.  @RequestParam(optional=true) - для снятия

            Передача с помощью переменных пути:
      В этом случае запрос выглядит так: http://localhost:8080/home/blue - использовать только для
        обязательных параметров

        @RequestMapping("/home/{color}")
         public String home(
         @PathVariable String color,
         Model page) {
         page.addAttribute("username", "Katy");
         page.addAttribute("color", color);
         return "home.html";
         }


      Реализация списка товаров

      @Service
      public class ProductService {
       private List<Product> products = new ArrayList<>();
       public void addProduct(Product p) {
       products.add(p);
       }
       public List<Product> findAll() {
       return products;
       }
       }

       @Controller
       public class ProductsController {
        private final ProductService productService;
        public ProductsController(ProductService productService) {
        this.productService = productService;
        }
        @RequestMapping("/products")
        public String viewProducts(Model model) {
        var products = productService.findAll();
        model.addAttribute("products", products);
        return "products.html";
        }
       }

       <!DOCTYPE html>
       <html lang="en" xmlns:th="http://www.thymeleaf.org">
        <head>
        <meta charset="UTF-8">
        <title>Home Page</title>
        </head>
        <body>
        <h1>Products</h1>
        <h2>View products</h2>
        <table>
        <tr>
        <th>PRODUCT NAME</th>
        <th>PRODUCT PRICE</th>
        </tr>
        <tr th:each="p: ${products}" >
        <td th:text="${p.name}"></td>
        <td th:text="${p.price}"></td>
        </tr>
        </table>
        </body>
       </html>

        Добавление продукта

         @RequestMapping(path = "/products",
         method = RequestMethod.POST)
          public String addProduct(
          @RequestParam String name,
          @RequestParam double price,
          Model model
          ) {
          Product p = new Product();
          p.setName(name);
          p.setPrice(price);
          productService.addProduct(p);
          var products = productService.findAll();
          model.addAttribute("products", products);
          return "products.html";
          }
         }

         <!DOCTYPE html>
         <html lang="en" xmlns:th="http://www.thymeleaf.org">
          <head>
          <meta charset="UTF-8">
          <title>Home Page</title>
          </head>
          <body>
          <!-- Остальной код -->
          <h2>Add a product</h2>
          <form action="/products" method="POST"> - Создание пост запроса
          Name: <input
          type="text"
          name="name"><br /> - позволяет внести наименование товара
          Price: <input
          type="number"
          step="any"
          name="price"><br /> - позволяет внести цену товара
          <button type="submit">Add product</button> - позволяет отправить форму
          </form>
          </body>
         </html>
_______________________________________________________________________________________________________________________
    Управление БД

    СУБД - обеспечение, для организации эффективной работы с БД

    Реляционные БД - Spring boot starter jpa (Hibernate(jacarta persistens API)) + (PostgreSQL(JDBS Driver))

    Java Database Connectivity (JDBC). JDBC — это способ установить подключение к СУБД для взаимодействия
        с базой данных.

    Драйвер необходим для обеспечения отдельных реализаций для работы с конкретными технологиями MySql or Postgres
    т.е. подключаться к БД для работы с абстракциями

    Приложение взаимодействует с абстракциями которые реализует JDBC драйвер, подключенный к СУБД

    Первый вариант использования драйвера - непосредственное подключение к СУБД, приложение запрашивает соединение с БД
        каждый раз, когда требуется выполнить операцию
        Connection con = DriverManager.getConnection(url, username, password);

    Второй вариант - создать объект источника данных - это объект, обязанность которого состоит в управлении
    соединениями приложения с сервером БД HikariCP (Hikari connection pool — пул соединений Hikari).
    Минимальный функционал

    JdbcTemplate — самый простой из инструментов Spring, предназначенных для работы с реляционными базами данных.

    H2 - БД, хранящаяся в оперативной памяти

    NySQL - нетребовательная к ресурсам СУБД

    Репозиторий — это класс, отвечающий за взаимодействие с базой данных.

    <dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter-jdbc</artifactId>
    </dependency>
    <dependency>
     <groupId>com.h2database</groupId>
     <artifactId>h2</artifactId>
    <scope>runtime</scope>
     </dependency>

     В папке ресурсов создаем schema.sql - записсываются запросы, определяющие структуру БД

     CREATE TABLE IF NOT EXISTS purchase (
      id INT AUTO_INCREMENT PRIMARY KEY,
      product varchar(50) NOT NULL,
      price double NOT NULL
     );

     Бин для работы с сохраненными данными
        @Repository
        public class PurchaseRepository {
         private final JdbcTemplate jdbc;
         public PurchaseRepository(JdbcTemplate jdbc) {
         this.jdbc = jdbc;
         }
         public void storePurchase(Purchase purchase) {
         String sql =
         "INSERT INTO purchase VALUES (NULL, ?, ?)";
         jdbc.update(sql,
         purchase.getProduct(),
         purchase.getPrice());
         }
          public List<Purchase> findAllPurchases() {
          String sql = "SELECT * FROM purchase";                         - получение всех записей из таблицы

      RowMapper<Purchase> purchaseRowMapper = (r, i) -> {           - RowMapper сообщает Jdbc как преобразовать строку
          Purchase rowObject = new Purchase();
          rowObject.setId(r.getInt("id"));
          rowObject.setProduct(r.getString("product"));
          rowObject.setPrice(r.getBigDecimal("price"));
          return rowObject;
          };
          return jdbc.query(sql, purchaseRowMapper);
          }
        }

    В классе контроллера
        @RestController
        @RequestMapping("/purchase")
        public class PurchaseController {
         private final PurchaseRepository purchaseRepository;

         public PurchaseController(
         PurchaseRepository purchaseRepository) {
         this.purchaseRepository = purchaseRepository;
         }
         @PostMapping                                                    - Конечная точка для сохранения в бд данных
         public void storePurchase(@RequestBody Purchase purchase) {
         purchaseRepository.storePurchase(purchase);
         }
         @GetMapping                                                    - Для получения с БД
         public List<Purchase> findPurchases() {
         return purchaseRepository.findAllPurchases();
         }
        }

    RowMapper — объект, выполняющий преобразование строки из ResultSet в заданный объект

    ОФТОП для цен - BigDecimal
    JPA (Java/Jakarta Persistens API) - спецификация, предоставляет набор анотация для описания класса синхронизации
    с БД + правила реализации ORM

    hibernate - ORM Framework, самодостаточная реализация JPA,

    Spring Data - объединяет под собой репозитории

    Зависимости,    SB starter data jpa
                    postgresql - драйвер
                    flyway-core

    @Entity - Класс должен синхронизироваться с БД (работает только с SpringData JPA) - У каждого объекта должен быть ID
    @Table- задаем имя таблицы
    @Column - переименовать столбец (nullable = false не может быть пустым, unique = true параметр уникален)
                                                    @columDefinition = "text[]" - явно задать тип данных
                                                    @JDbcTypeCode (прописываем актуальный формат для таблицы (SQL))
                                                    insertable = fals - параметр не регистрируется при сохранении,
                                                      ставится по умолчанию
                                                    updateble = false - столбец нельзя обновить из запроса обновления

    __
    Если делаем перечисоение -> @Enumerated(EnumType.STRING) - задаем тип перечисления
                                @Column(name - "type", nullable = false) - значение будет храниться как строчка
    __

    У сущности связи можно настраивать не с объектом полностью (тогда подгружается его все данные), а только с ID
        и подгружать данные по запросу. В этом случае:
        @Many to one(targetEntity = User.class) - для ORM указываем поле, соответствующее классу
        @Query(nativeQuery = true, пишем sql запрос) - если не сгенерировать автоматически - Можем переопределить
                                                                    запросы из CRUD

        @Transactional - при выполнении запроса открывается закрывается транзакция
        @Modifying - ставим, если переписываем CRUD

    Параметр fetch доступен на анотациях связи.
                            Если связь заканчивается на One - по умолчанию Eager жадное
                                                        Many- по умолчанию Lazy ленивое
                Обозначает как будет извлекаться данные при вызове. Ленивая - не извлекает данные при извлечении, жадная
                    подтягивает все из другой таблички. Ленивый подтягивает более свежую информацию, жадный ускоряет
    Параметр MappedBy - (mappedBy = " ") - не нужно формировать список, подтягиваем его из другой таблицы


    @JoinColumn - формируются благодаря связям, там joinColumns и inverseJoinColumns

    ORM - object relationship management сопоставляет сущности Java и БД
    ORM создает БД с помощью миграций (процесс), для более тонкой настройки используются дополнительные библиотеки:
    liquidbase/flyway  - управление структурой БД. Changlog выполняются при старте приложений. Требуется обновление в
    applicationproperty
    Jpa Buddy Plugin - управляет созданием

    Возможно записать файлы sсhema.sql (создание, связь, удаление) data.sql(наполнение таблиц)

    ПАГИНАЦИЯ: можем оформить самостоятельно или :
            Pageable pegeable = PageRequest.of(page, size, Sort.by("name"));
                        page - номер страницы
                        size - количество записей

    В сервисе можем вызвать Page объект и передать его в DTO

    ВАЛИДАЦИЯ
    Может быть применена к любым объектам, по приходам в БД, реализуется на уровне кода.
        Аннотаций для валидаций большое количество, названия говорящие. Входят в библиотеку jakarta.validation
        В классе ставим аннотацию @Validated там, где нужно чтобы валидация отработала



    Changelog - файлики с командами для управления. Результирующий файл также changelog
    Changelog - состаит из changset (к примеру: создание таблицы, обновление таблицы, создание связи между таблицами)
    м.б. представлени как xml, sql команды

    Управление состояние БД - управление миграциями
_______________________________________________________________________________________________________________________
    Многопоточка используется также как и в Java Core                                                                   @Configuration
    Если нужно создать пул потоков - создается бин, по имени которого потом вызываем                                    public class ProjectConfiguration {
    1 метод - 1 пул, возвразаем экзекьютор
    Когда хотим выполнить какой-либо метод как асинхронную задачу, над ним ставим @Async("название пула")               public Executor orderExecutor(){
    Прописываем метод в анатации которого обозначаем пул - расписываем пул - в сервисе вызываемметод                    ThreadPoolTaskExecutor executor =
                                                                                                                                        new ThreadPoolTaskExecutor();
    Запуск по расписанию:                                                                                                       executor.setCorePoolSize(1);
        @EnebleScheduling - аннотация над классом для запуска метода по расписанию                                              executor.setMaxPoolSize(5);
        @Scheduled - над самим методом + @Async - будет пул спринга                                                             executor.setQueueCapacity(20);
                                                                                                                                executor.setKeepAliveSeconds(60);
        Для работы с временем метод должен имплементить Delayed                                                                 executor.setThreadNamePrefix("XXX-EXECUTOR-");
        переопределять getDelay и compareTo                                                                                     executor.initialize();
                                                                                                                                return executor;
                                                                                                                            }
                                                                                                                        }
_______________________________________________________________________________________________________________________
    Ошибки/Исключения
    Можем создавать Exception и создавать их иерархию
    Ошибку проверяем через if если не проходим - выкидываем Exception, если проходим - отдаем результат
    За счет дополненния кастомной ошибки своего исключения, можем добавлять поле статус, и выделять кастомную ошибку
    Для необычных ошибок, но постоянных (вместо 500-ой должны возвращать 200) можно использовать Controller Advice - Это
    нестандартная постоянная ситуация.
    Либо Controller Advice через @ControllerAdvice
    Для обработки исключения @ExceptionHandler (вид исключения для обработки) - пишем паблик метод с своим названием
    Он будет перехватывать ошибки и экземпляр придет в этот метод.
    Получаем метод и статус.
                             @ResponseStatus задаем статус, тогда обработка будет в Controller Advice
                             @ResponseBody - в теле уйдет тело в метод обработки

                                        либо ResponseStatusExceptions - Service - throw new танзвание (статус, сообщение)
                                        в Controller в блоке try-cath перехватываем
    @ExceptionHandler
    @ResponseStatusException - используется на уровне контроллера

    На каждый статус возвращается своя страничка или прописывается единообразная

_______________________________________________________________________________________________________________________

    Java Mail Sender
    Настройки находятся в проперти файле для отправки писем
    smtp(465)/smtps(8043)

    Создается письмо в SimpleMeilMessege (setFrom, setTo, setSubject, setText)
    Вложения реализуются через MimeMessage (файлики)
    Если прописано взаимодействие с сторонним сервисом, то через http
_______________________________________________________________________________________________________________________
    Логирование
    Возможности включены в Spring Boot - @Slf4j дает доступ к log. Default - Log4j
                    info - хотим зафиксировать какую-либо информацию (остается в промышленной среде и попадает в логи)
                    debug - информация для отладки (только на стадии разработки)
                    error - логирование Exception

            МОжешь просто передать строчку, а можем добавить объект Frolable или на какой либо другой объект
_______________________________________________________________________________________________________________________
    Docer
Ставим докер - докер демон (серверное приложение) выполняет весь необходимый функционал
    Клиенское приложение - консоль или десктоп
    Докер реестр - удаленная платформа, в ней хранятся образы того, что ы запускаем
    репозитории докеров - тоже для хранения


    В образе файл с инструкциями, докер компоуз - инструмент, используется если нам нужно запустить несколько приложений
    Контейнер - готовая среда для запуска.
    В промышленной среде докер может использоваться по-другому - докеры кафки и субд не разворачиваются


_______________________________________________________________________________________________________________________
    Kafka
    Кафка - система, приложение, не принадлежэит проекту.
    Ставится и устанавливается отдельно.
    Для в.д. с кафкой - org.springframework.kafka, у кафки свой блок секьюрити
    Настройки для произвордителей и для потребителей отличаются, но есть часть общих
    Информация делится по топикам (темам) - один род информации для одного топика
    С одним топиком могут взаимодействовать как несколько потребителей, так и несколько производителей
    Топики делятся на разделы (партиции)
    Производителей у партицей мб много. мб закреплены за одним производителем
    1 раздел - 1 потребитель
    индекс в разделе - смещения. Если за одним разделом несколько потребителей, то они будут конкурировать
    После каждого прочтения фиксируется функционал коммита
    авто коммиты могут привести в случае разрыва связи- лучше отключать - тогда могут возникать дубли, используются если
    скорость важнее потерь
    Производитель знает только дошло ли до кафки информация или нет
    Ограничение кафки - ресурсы

    Минусы - нет информации совершена ли доставка - рядом можно создать еще один топик куда потребитель пишет что получил, что не получил
    Потребитель становится производителем информации по ошибкам

        Данные в топиках храняться определенное количество времени, соответственно новый потребитель не знает старые данные

        Физические файлы не добавляем в кафку, только ссылки

    На стороне пполучателя должна быть выстроена система с синхронизации топиков - две бд, одна синхрон другая нет (записывается изначально)

    Когда производитель добавляет информацию в топик, к этому сооббщению можно добавить мета информацию
    К сообщению можно добавить ключ и по ключам и по ключам делить на партиции

    Должны быть выполнены события, чтобы прозводились сообщения в кафку

   или по времени (слушатель кафки)


   Очереди 1 очередь - один производитель
   в очереди есть приоритеты и так продвинуть сообщение в очередь
   получатель получает сообщения с более высоким приоритетом
    система обратного оповещеня
    пропускная способность ниже

_______________________________________________________________________________________________________________________

    Балансировщик
      При вд нескольких образцов приложение должно знать куда отправлять сообщение
      Рядом с отправителем размещается балансировщик, который зает состояние получателя (Хапрокси)
      Балансировщик мб на исходящий или на входящий прокси (Иджинкс)

      Если делаем без всего, то можем реализовать на уровне кода в спринг клауд

_______________________________________________________________________________________________________________________
    Логирование трасировка мониторинг - обсервабилити - наблюдаемострь
        В реальности это неудобно т.к. нет единого механизма

    Логирование - в приложении есть логи
    в логировании несколько уровень - ошибки, предупреждение, информации, дебага
    ошибки - всегда логируются
    Каждое приложение пишет свой лог файл

    Два стека технологий логирования - ELK эластик стерч - хранилище, база.
    Л - лог стэйч - пришедшие логи обрабатываются и приставляются в нужном формате
    к - кебана - для реализации

    рядом с приложением устанавливается файл бит где все пишется
    елк можеот работать с метнриками - но сейчас в разработке и никто не работает с эти
    проблема елк в санкциях, так как не в полноценном виде

    еще есть опен серч вместо буквы е - опен серч ддашборт - вместо кебана могут передаваться тем же самым файл битом
                                                                        и обрабатываться тем же самым логстейджем
    Помимо этого опен серч вместо файлбита может использовать флюинт бит - тоже самое но передает в опен серч
    Флюинтиб - хранилище


    метрики - относятся к системе мониторинга - количественные показатели

    Сбор метрик - нормальный вариант - есть хранилище метрик
    есть агент, который эти метрики собирает, у приложения есть энд поинты в контроллерах
    агент обращается в криложению забирает информацию - в спринг бут библиотека актуатор она способна собирать самостоятельно
    предоставляет поинт для работоспособности системы и эти метрики связаны с дисковым пространством и прочим
    +позволяет описать собственные метрики которые можно описать по эндпоинтам

    хранятся в с истеме хранения (промитеус), то что там хранится обрабатывает ся (виктория) или необрабатывается. а сразу визуализируется
    графана - для визуализации метрик

    Графане нужен постгресс и еще есть приложение, следящее за порогами - способен отправить письмо на почту


    трассировка - отслеживание запроса по сем сервисам которыые задействованы


